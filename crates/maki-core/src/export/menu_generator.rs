//! Menu XML Generator for FHIR IG Publisher
//!
//! This module generates menu.xml from sushi-config.yaml's `menu` field,
//! following SUSHI's output format for compatibility with IG Publisher.
//!
//! ## Menu Configuration Formats
//!
//! The menu field supports map format (common in SUSHI configs):
//!
//! ```yaml
//! menu:
//!   Home: index.html
//!   Content by Group:
//!     Patient: group-patient.html
//!     Disease: group-disease.html
//! ```
//!
//! **Reference**: SUSHI's `src/ig/IGExporter.ts` `addMenuXML()` method

use serde_json::{Map, Value as JsonValue};

/// Warning header for generated menu.xml (SUSHI-compatible)
const MENU_XML_HEADER: &str = r#"<!-- menu.xml {% comment %}
  *** WARNING: DO NOT EDIT THIS FILE ***

  This file was generated by maki. To change the contents of this file, edit
  the "menu" attribute in the sushi-config.yaml file or provide your own menu.xml
  in the input/includes folder.

{% endcomment %} -->
"#;

/// Menu XML generator
pub struct MenuGenerator;

impl MenuGenerator {
    /// Generate menu.xml content from configuration
    ///
    /// Returns `None` if the menu config is empty or invalid
    pub fn generate(menu_config: &JsonValue) -> Option<String> {
        let menu_map = menu_config.as_object()?;

        if menu_map.is_empty() {
            return None;
        }

        let mut xml = String::new();
        xml.push_str(MENU_XML_HEADER);
        xml.push_str("<ul xmlns=\"http://www.w3.org/1999/xhtml\" class=\"nav navbar-nav\">\n");

        for (name, value) in menu_map {
            xml.push_str(&Self::build_menu_item(name, value, 1));
        }

        xml.push_str("</ul>\n");

        Some(xml)
    }

    /// Build a menu item (handles both simple links and dropdowns)
    fn build_menu_item(name: &str, value: &JsonValue, indent: usize) -> String {
        let spaces = "  ".repeat(indent);
        let encoded_name = Self::encode_menu_name(name);

        match value {
            // Simple link: "Home": "index.html"
            JsonValue::String(url) => {
                format!("{spaces}<li>\n{spaces}  <a href=\"{url}\">{encoded_name}</a>\n{spaces}</li>\n")
            }
            // Dropdown submenu: "Content": { "Page1": "url1", "Page2": "url2" }
            JsonValue::Object(submenu) => Self::build_submenu(&encoded_name, submenu, indent),
            // Unsupported value type - skip
            _ => String::new(),
        }
    }

    /// Build a dropdown submenu
    fn build_submenu(name: &str, items: &Map<String, JsonValue>, indent: usize) -> String {
        let spaces = "  ".repeat(indent);
        let mut xml = String::new();

        xml.push_str(&format!("{spaces}<li class=\"dropdown\">\n"));
        xml.push_str(&format!(
            "{spaces}  <a data-toggle=\"dropdown\" href=\"#\" class=\"dropdown-toggle\">{name}\n"
        ));
        xml.push_str(&format!("{spaces}    <b class=\"caret\"></b>\n"));
        xml.push_str(&format!("{spaces}  </a>\n"));
        xml.push_str(&format!("{spaces}  <ul class=\"dropdown-menu\">\n"));

        for (item_name, item_value) in items {
            let encoded_name = Self::encode_menu_name(item_name);

            match item_value {
                JsonValue::String(url) => {
                    xml.push_str(&format!(
                        "{spaces}    <li>\n{spaces}      <a href=\"{url}\">{encoded_name}</a>\n{spaces}    </li>\n"
                    ));
                }
                // Nested submenu (3+ levels) - SUSHI warns but still writes
                // IG Publisher only supports 2 levels of nesting
                JsonValue::Object(nested) => {
                    tracing::warn!(
                        "Menu item '{}' has nested submenu - IG Publisher only supports 2 levels",
                        item_name
                    );
                    // Still write it for completeness
                    xml.push_str(&Self::build_submenu(&encoded_name, nested, indent + 2));
                }
                _ => {}
            }
        }

        xml.push_str(&format!("{spaces}  </ul>\n"));
        xml.push_str(&format!("{spaces}</li>\n"));

        xml
    }

    /// Escape XML special characters in menu names
    ///
    /// Follows SUSHI's `encodeMenuName()` function
    fn encode_menu_name(name: &str) -> String {
        let mut result = String::with_capacity(name.len());

        let mut chars = name.chars().peekable();
        while let Some(c) = chars.next() {
            match c {
                '"' => result.push_str("&quot;"),
                '\'' => result.push_str("&apos;"),
                '<' => result.push_str("&lt;"),
                '>' => result.push_str("&gt;"),
                '&' => {
                    // Don't double-escape already escaped entities
                    // Check if this looks like an entity (e.g., &amp;, &lt;, etc.)
                    let remaining: String = chars.clone().take(10).collect();
                    if remaining.contains(';')
                        && remaining
                            .split(';')
                            .next()
                            .map_or(false, |entity| is_valid_entity(entity))
                    {
                        result.push('&');
                    } else {
                        result.push_str("&amp;");
                    }
                }
                _ => result.push(c),
            }
        }

        result
    }
}

/// Check if a string looks like a valid XML entity name
fn is_valid_entity(s: &str) -> bool {
    if s.is_empty() {
        return false;
    }

    // Numeric entity: #123 or #x1a
    if let Some(rest) = s.strip_prefix('#') {
        if let Some(hex) = rest.strip_prefix('x') {
            return !hex.is_empty() && hex.chars().all(|c| c.is_ascii_hexdigit());
        }
        return !rest.is_empty() && rest.chars().all(|c| c.is_ascii_digit());
    }

    // Named entity: letters only
    !s.is_empty() && s.chars().all(|c| c.is_ascii_alphabetic())
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_simple_menu() {
        let menu = json!({
            "Home": "index.html"
        });

        let xml = MenuGenerator::generate(&menu).unwrap();

        assert!(xml.contains("WARNING: DO NOT EDIT"));
        assert!(xml.contains("<ul xmlns=\"http://www.w3.org/1999/xhtml\""));
        assert!(xml.contains("<a href=\"index.html\">Home</a>"));
    }

    #[test]
    fn test_dropdown_menu() {
        let menu = json!({
            "Content": {
                "Page 1": "page1.html",
                "Page 2": "page2.html"
            }
        });

        let xml = MenuGenerator::generate(&menu).unwrap();

        assert!(xml.contains("class=\"dropdown\""));
        assert!(xml.contains("class=\"dropdown-toggle\""));
        assert!(xml.contains("<b class=\"caret\">"));
        assert!(xml.contains("class=\"dropdown-menu\""));
        assert!(xml.contains("<a href=\"page1.html\">Page 1</a>"));
        assert!(xml.contains("<a href=\"page2.html\">Page 2</a>"));
    }

    #[test]
    fn test_mixed_menu() {
        let menu = json!({
            "Home": "index.html",
            "Content": {
                "About": "about.html"
            }
        });

        let xml = MenuGenerator::generate(&menu).unwrap();

        assert!(xml.contains("<a href=\"index.html\">Home</a>"));
        assert!(xml.contains("class=\"dropdown\""));
        assert!(xml.contains("<a href=\"about.html\">About</a>"));
    }

    #[test]
    fn test_encode_special_chars() {
        assert_eq!(MenuGenerator::encode_menu_name("Test"), "Test");
        assert_eq!(MenuGenerator::encode_menu_name("A & B"), "A &amp; B");
        assert_eq!(MenuGenerator::encode_menu_name("1 < 2"), "1 &lt; 2");
        assert_eq!(MenuGenerator::encode_menu_name("2 > 1"), "2 &gt; 1");
        assert_eq!(MenuGenerator::encode_menu_name("Say \"Hi\""), "Say &quot;Hi&quot;");
        assert_eq!(MenuGenerator::encode_menu_name("It's"), "It&apos;s");
    }

    #[test]
    fn test_preserve_existing_entities() {
        // Already escaped entities should not be double-escaped
        assert_eq!(MenuGenerator::encode_menu_name("A &amp; B"), "A &amp; B");
        assert_eq!(MenuGenerator::encode_menu_name("&lt;tag&gt;"), "&lt;tag&gt;");
    }

    #[test]
    fn test_empty_menu_returns_none() {
        let menu = json!({});
        assert!(MenuGenerator::generate(&menu).is_none());
    }

    #[test]
    fn test_invalid_menu_returns_none() {
        let menu = json!("not an object");
        assert!(MenuGenerator::generate(&menu).is_none());
    }

    #[test]
    fn test_is_valid_entity() {
        assert!(is_valid_entity("amp"));
        assert!(is_valid_entity("lt"));
        assert!(is_valid_entity("gt"));
        assert!(is_valid_entity("quot"));
        assert!(is_valid_entity("#123"));
        assert!(is_valid_entity("#x1a2b"));

        assert!(!is_valid_entity(""));
        assert!(!is_valid_entity("123abc"));
        assert!(!is_valid_entity("#"));
        assert!(!is_valid_entity("#x"));
    }
}
