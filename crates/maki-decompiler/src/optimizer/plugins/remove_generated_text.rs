//! Remove generated text rules optimization
//!
//! Removes text.div and text.status rules when text is auto-generated by FHIR system.

use crate::{
    Result,
    exportable::{AssignmentRule, CaretValueRule, Exportable, ExportableRule, FshValue},
    lake::ResourceLake,
    optimizer::{OptimizationStats, Optimizer},
};
use log::debug;

/// Removes text-related rules when text is auto-generated
///
/// This optimizer removes text.div and text.status rules when:
/// - text.status = "generated" or "extensions"
///
/// These rules are redundant since the text is auto-generated by the FHIR system.
pub struct RemoveGeneratedTextRulesOptimizer;

impl Optimizer for RemoveGeneratedTextRulesOptimizer {
    fn name(&self) -> &str {
        "remove-generated-text"
    }

    fn optimize(
        &self,
        exportable: &mut dyn Exportable,
        _lake: &ResourceLake,
    ) -> Result<OptimizationStats> {
        let mut stats = OptimizationStats::new();

        let rules = exportable.get_rules_mut();

        // First, check if text.status is "generated" or "extensions"
        let has_generated_text = Self::has_generated_text(rules);

        if !has_generated_text {
            return Ok(stats);
        }

        debug!("Found generated text, removing text-related rules");

        // Find all text-related rules to remove
        let mut indices_to_remove = Vec::new();

        for (idx, rule) in rules.iter().enumerate() {
            // Check CaretValueRule with caretPath starting with "text."
            if let Some(caret_rule) = rule.as_any().downcast_ref::<CaretValueRule>() {
                if caret_rule.path.is_none() && caret_rule.caret_path.starts_with("text.") {
                    debug!(
                        "Removing caret rule for generated text: {}",
                        caret_rule.caret_path
                    );
                    indices_to_remove.push(idx);
                    stats.record_redundant();
                }
            }
            // Check AssignmentRule with path starting with "text."
            else if let Some(assign_rule) = rule.as_any().downcast_ref::<AssignmentRule>()
                && assign_rule.path.starts_with("text.")
            {
                debug!(
                    "Removing assignment rule for generated text: {}",
                    assign_rule.path
                );
                indices_to_remove.push(idx);
                stats.record_redundant();
            }
        }

        // Remove in reverse order to maintain correct indices
        for idx in indices_to_remove.into_iter().rev() {
            rules.remove(idx);
        }

        Ok(stats)
    }
}

impl RemoveGeneratedTextRulesOptimizer {
    /// Check if exportable has generated text (text.status = "generated" or "extensions")
    fn has_generated_text(rules: &[Box<dyn ExportableRule>]) -> bool {
        for rule in rules {
            // Check CaretValueRule
            if let Some(caret_rule) = rule.as_any().downcast_ref::<CaretValueRule>() {
                if caret_rule.path.is_none() && caret_rule.caret_path == "text.status" {
                    if let FshValue::Code(code) = &caret_rule.value
                        && (code.code == "generated" || code.code == "extensions")
                    {
                        return true;
                    }
                    if let FshValue::String(s) = &caret_rule.value
                        && (s == "generated" || s == "extensions")
                    {
                        return true;
                    }
                }
            }
            // Check AssignmentRule
            else if let Some(assign_rule) = rule.as_any().downcast_ref::<AssignmentRule>()
                && assign_rule.path == "text.status"
            {
                if let FshValue::Code(code) = &assign_rule.value
                    && (code.code == "generated" || code.code == "extensions")
                {
                    return true;
                }
                if let FshValue::String(s) = &assign_rule.value
                    && (s == "generated" || s == "extensions")
                {
                    return true;
                }
            }
        }
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::exportable::{ExportableProfile, FshCode};
    use crate::lake::ResourceLake;
    use maki_core::canonical::{CanonicalFacade, CanonicalOptions, FhirRelease};
    use std::sync::Arc;

    async fn create_test_lake() -> ResourceLake {
        let options = CanonicalOptions {
            quick_init: true,
            auto_install_core: false,
            ..Default::default()
        };
        let facade = CanonicalFacade::new(options).await.unwrap();
        let session = facade.session(vec![FhirRelease::R4]).await.unwrap();
        ResourceLake::new(Arc::new(session))
    }

    #[tokio::test]
    async fn test_remove_text_rules_when_generated() {
        let mut profile = ExportableProfile::new("TestProfile".to_string(), "Patient".to_string());

        // Add text.status = "generated"
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.status".to_string(),
            value: FshValue::Code(FshCode {
                system: None,
                code: "generated".to_string(),
            }),
        }));

        // Add text.div (should be removed)
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.div".to_string(),
            value: FshValue::String("<div>Some text</div>".to_string()),
        }));

        // Add unrelated rule (should remain)
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "status".to_string(),
            value: FshValue::Code(FshCode {
                system: None,
                code: "active".to_string(),
            }),
        }));

        let lake = create_test_lake().await;
        let optimizer = RemoveGeneratedTextRulesOptimizer;

        let stats = optimizer.optimize(&mut profile, &lake).unwrap();

        assert_eq!(stats.redundant_rules, 2); // text.status and text.div removed
        assert_eq!(profile.rules.len(), 1); // Only status remains
    }

    #[tokio::test]
    async fn test_keep_text_rules_when_not_generated() {
        let mut profile = ExportableProfile::new("TestProfile".to_string(), "Patient".to_string());

        // Add text.status = "additional" (not generated)
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.status".to_string(),
            value: FshValue::Code(FshCode {
                system: None,
                code: "additional".to_string(),
            }),
        }));

        // Add text.div (should NOT be removed)
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.div".to_string(),
            value: FshValue::String("<div>Custom text</div>".to_string()),
        }));

        let lake = create_test_lake().await;
        let optimizer = RemoveGeneratedTextRulesOptimizer;

        let stats = optimizer.optimize(&mut profile, &lake).unwrap();

        assert_eq!(stats.redundant_rules, 0);
        assert_eq!(profile.rules.len(), 2);
    }

    #[tokio::test]
    async fn test_remove_text_assignment_rules() {
        let mut profile = ExportableProfile::new("TestProfile".to_string(), "Patient".to_string());

        // Add text.status assignment = "generated"
        profile.add_rule(Box::new(AssignmentRule {
            path: "text.status".to_string(),
            value: FshValue::String("generated".to_string()),
            exactly: false,
        }));

        // Add text.div assignment (should be removed)
        profile.add_rule(Box::new(AssignmentRule {
            path: "text.div".to_string(),
            value: FshValue::String("<div>Some text</div>".to_string()),
            exactly: false,
        }));

        let lake = create_test_lake().await;
        let optimizer = RemoveGeneratedTextRulesOptimizer;

        let stats = optimizer.optimize(&mut profile, &lake).unwrap();

        assert_eq!(stats.redundant_rules, 2); // Both text rules removed
        assert_eq!(profile.rules.len(), 0);
    }

    #[tokio::test]
    async fn test_extensions_status_also_triggers_removal() {
        let mut profile = ExportableProfile::new("TestProfile".to_string(), "Patient".to_string());

        // Add text.status = "extensions"
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.status".to_string(),
            value: FshValue::String("extensions".to_string()),
        }));

        // Add text.div (should be removed)
        profile.add_rule(Box::new(CaretValueRule {
            path: None,
            caret_path: "text.div".to_string(),
            value: FshValue::String("<div>Extensions text</div>".to_string()),
        }));

        let lake = create_test_lake().await;
        let optimizer = RemoveGeneratedTextRulesOptimizer;

        let stats = optimizer.optimize(&mut profile, &lake).unwrap();

        assert_eq!(stats.redundant_rules, 2);
        assert_eq!(profile.rules.len(), 0);
    }
}
