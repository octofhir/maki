//! Round-Trip Tests: FHIR → FSH → FHIR
//!
//! These tests verify that decompiling FHIR to FSH and then recompiling
//! back to FHIR results in semantically equivalent resources.
//!
//! Note: These tests require SUSHI to be installed and are ignored by default.
//! Run with: `cargo test --package maki-decompiler round_trip -- --ignored`

use maki_decompiler::models::*;
use maki_decompiler::test_helpers::*;
use maki_decompiler::*;
use serial_test::serial;
use std::fs;
use std::process::Command;
use tempfile::TempDir;

/// Helper to decompile a StructureDefinition to FSH
async fn decompile_to_fsh(sd: &StructureDefinition) -> Result<String> {
    let session = setup_canonical_environment(parse_fhir_release("R4").unwrap(), vec![]).await?;
    let lake = ResourceLake::new(session);
    let processor = StructureDefinitionProcessor::new(&lake);
    let exportable = processor.process(sd).await?;
    Ok(exportable.to_fsh())
}

/// Helper to compile FSH to FHIR using SUSHI
fn compile_fsh_with_sushi(fsh: &str, temp_dir: &TempDir) -> Result<serde_json::Value> {
    // Create sushi-config.yaml
    let config = r#"
id: test
canonical: http://example.org
name: Test
status: draft
version: 1.0.0
fhirVersion: 4.0.1
"#;
    fs::write(temp_dir.path().join("sushi-config.yaml"), config).map_err(Error::Io)?;

    // Create FSH file
    let fsh_dir = temp_dir.path().join("input").join("fsh");
    fs::create_dir_all(&fsh_dir).map_err(Error::Io)?;
    fs::write(fsh_dir.join("test.fsh"), fsh).map_err(Error::Io)?;

    // Run SUSHI
    let output = Command::new("sushi")
        .current_dir(temp_dir.path())
        .arg(".")
        .output()
        .map_err(Error::Io)?;

    if !output.status.success() {
        return Err(Error::Processing(format!(
            "SUSHI failed: {}",
            String::from_utf8_lossy(&output.stderr)
        )));
    }

    // Read the generated FHIR JSON
    let fhir_gen = temp_dir.path().join("fsh-generated").join("resources");
    let entries = fs::read_dir(&fhir_gen).map_err(Error::Io)?;

    for entry in entries {
        let entry = entry.map_err(Error::Io)?;
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) == Some("json") {
            let content = fs::read_to_string(&path).map_err(Error::Io)?;
            let json: serde_json::Value = serde_json::from_str(&content).map_err(Error::Json)?;
            return Ok(json);
        }
    }

    Err(Error::Processing(
        "No FHIR JSON generated by SUSHI".to_string(),
    ))
}

/// Check if SUSHI is available
fn is_sushi_available() -> bool {
    Command::new("sushi").arg("--version").output().is_ok()
}

// ============================================================================
// ROUND-TRIP TESTS (10+ tests)
// ============================================================================

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_simple_profile() {
    if !is_sushi_available() {
        println!("SUSHI not available, skipping test");
        return;
    }

    let original = fixtures::simple_patient_profile();
    let fsh = decompile_to_fsh(&original).await.unwrap();

    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    // Basic checks - semantic equivalence would require more sophisticated comparison
    assert_eq!(
        recompiled.get("resourceType").and_then(|v| v.as_str()),
        Some("StructureDefinition")
    );
    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("SimplePatientProfile")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_complex_profile() {
    if !is_sushi_available() {
        return;
    }

    let original = fixtures::complex_patient_profile();
    let fsh = decompile_to_fsh(&original).await.unwrap();

    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("ComplexPatientProfile")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_with_slicing() {
    if !is_sushi_available() {
        return;
    }

    let original = fixtures::observation_with_slicing();
    let fsh = decompile_to_fsh(&original).await.unwrap();

    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("ObservationWithSlicing")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_with_bindings() {
    if !is_sushi_available() {
        return;
    }

    let profile = TestProfileBuilder::new(
        "ObservationWithBinding",
        "http://example.org/StructureDefinition/ObservationWithBinding",
    )
    .with_base("http://hl7.org/fhir/StructureDefinition/Observation")
    .with_differential(vec![
        TestElementBuilder::new("Observation").build(),
        TestElementBuilder::new("Observation.status")
            .with_binding(
                "http://hl7.org/fhir/ValueSet/observation-status",
                BindingStrength::Required,
            )
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&profile).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("ObservationWithBinding")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_with_cardinality() {
    if !is_sushi_available() {
        return;
    }

    let profile = TestProfileBuilder::new(
        "PatientWithCardinality",
        "http://example.org/StructureDefinition/PatientWithCardinality",
    )
    .with_differential(vec![
        TestElementBuilder::new("Patient").build(),
        TestElementBuilder::new("Patient.identifier")
            .with_cardinality(1, "*")
            .build(),
        TestElementBuilder::new("Patient.name")
            .with_cardinality(1, "3")
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&profile).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("PatientWithCardinality")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_with_flags() {
    if !is_sushi_available() {
        return;
    }

    let profile = TestProfileBuilder::new(
        "PatientWithFlags",
        "http://example.org/StructureDefinition/PatientWithFlags",
    )
    .with_differential(vec![
        TestElementBuilder::new("Patient").build(),
        TestElementBuilder::new("Patient.identifier")
            .with_must_support(true)
            .build(),
        TestElementBuilder::new("Patient.active")
            .with_is_modifier(true)
            .build(),
        TestElementBuilder::new("Patient.gender")
            .with_is_summary(true)
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&profile).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("PatientWithFlags")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_with_fixed_values() {
    if !is_sushi_available() {
        return;
    }

    let profile = TestProfileBuilder::new(
        "PatientWithFixedValues",
        "http://example.org/StructureDefinition/PatientWithFixedValues",
    )
    .with_differential(vec![
        TestElementBuilder::new("Patient").build(),
        TestElementBuilder::new("Patient.active")
            .with_fixed_boolean(true)
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&profile).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("PatientWithFixedValues")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_extension() {
    if !is_sushi_available() {
        return;
    }

    let extension = TestProfileBuilder::new(
        "SimpleExtension",
        "http://example.org/StructureDefinition/SimpleExtension",
    )
    .with_base("http://hl7.org/fhir/StructureDefinition/Extension")
    .with_kind(StructureDefinitionKind::ComplexType)
    .with_differential(vec![
        TestElementBuilder::new("Extension").build(),
        TestElementBuilder::new("Extension.value[x]")
            .with_cardinality(1, "1")
            .with_type("string")
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&extension).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("SimpleExtension")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_type_constraints() {
    if !is_sushi_available() {
        return;
    }

    let profile = TestProfileBuilder::new(
        "ObservationWithTypeConstraints",
        "http://example.org/StructureDefinition/ObservationWithTypeConstraints",
    )
    .with_base("http://hl7.org/fhir/StructureDefinition/Observation")
    .with_differential(vec![
        TestElementBuilder::new("Observation").build(),
        TestElementBuilder::new("Observation.value[x]")
            .with_type("Quantity")
            .build(),
    ])
    .build();

    let fsh = decompile_to_fsh(&profile).await.unwrap();
    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    assert_eq!(
        recompiled.get("name").and_then(|v| v.as_str()),
        Some("ObservationWithTypeConstraints")
    );
}

#[tokio::test]
#[serial]
#[ignore] // Requires SUSHI
async fn test_round_trip_semantic_equivalence() {
    if !is_sushi_available() {
        return;
    }

    // This test uses the SUSHI compatibility framework to verify semantic equivalence
    let original = fixtures::simple_patient_profile();
    let fsh = decompile_to_fsh(&original).await.unwrap();

    let temp_dir = TempDir::new().unwrap();
    let recompiled = compile_fsh_with_sushi(&fsh, &temp_dir).unwrap();

    // Use the comparator from maki-integration-tests
    // For now, we'll do basic validation
    assert_eq!(
        recompiled.get("resourceType"),
        Some(&serde_json::Value::String(
            "StructureDefinition".to_string()
        ))
    );
}

// ============================================================================
// HELPER TESTS
// ============================================================================

#[test]
fn test_sushi_availability() {
    let available = is_sushi_available();
    println!("SUSHI available: {}", available);
    // This is informational only, not an assertion
}
